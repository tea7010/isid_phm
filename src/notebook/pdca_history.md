# 試行錯誤の記録

## 内部評価用データの作成
testは残寿命があるが、trainについては最後までフライトしたデータである。
最後までフライトしたデータを学習させて、最後までフライトしたデータで評価すると、途中で切られているtestデータにはうまくあてはまらなかった（内部スコアと提出スコアが、あまり一致しなかった）

提出No|アプローチ|内部スコア(改善前）|提出したスコア
-|-|-|-
2|回帰アプローチ|17.45|37.27

そこで、trainをtestと同じような感じで、途中で打ち切ることを試してみた。

`src/libs/train_cut_off`にコードがあるが、下記の流れで学習データに加工を行った。
1. testの各エンジンのdead_duration（打ち切られた期間）に対して、カーネル密度推定（分布の推定）を行う
1. できた推定分布からランダムサンプリングした、打ち切り数でtrainの各エンジンを打ち切り
1. 打ち切ったものを新しいtrainとし、学習・評価に用いる

提出No|アプローチ|内部スコア（改善後）|提出したスコア
-|-|-|-
2|回帰アプローチ|35.16|37.27

これにより、上記の表と比べると内部スコアが提出スコアに近くなった。


No|概要|validation結果|sunbit_score
-|-|-|-
1|trainの各エンジンの最終フライト数の平均を、予測フライト数とする|32.3|31
2|回帰アプローチ|35.16|37.27
3|SVR|24.58|25.66080435

実際、これまで3回のsubmitでこの評価方法を用いると、だいたいあってそうな内部評価ができている。
打ち切られたデータを学習し、打ち切られたデータで内部評価、打ち切られたデータに対して予測を行うという、直感的にもあってそうな評価方法が構築できた。